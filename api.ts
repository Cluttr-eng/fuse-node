/* tslint:disable */
/* eslint-disable */
/**
 * Fuse
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const Aggregator = {
    Plaid: 'plaid',
    Teller: 'teller',
    Mx: 'mx',
    Finicity: 'finicity'
} as const;

export type Aggregator = typeof Aggregator[keyof typeof Aggregator];


/**
 * 
 * @export
 * @interface CreateAssetReportRequest
 */
export interface CreateAssetReportRequest {
    /**
     * Access token for the entity to create report for.
     * @type {string}
     * @memberof CreateAssetReportRequest
     */
    'access_token': string;
    /**
     * The maximum integer number of days of history to include in the Asset Report
     * @type {number}
     * @memberof CreateAssetReportRequest
     */
    'days_requested': number;
    /**
     * Indicates whether to include identity data in the Asset Report
     * @type {boolean}
     * @memberof CreateAssetReportRequest
     */
    'include_identity'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateAssetReportResponse
 */
export interface CreateAssetReportResponse {
    /**
     * A token that can be provided to endpoints such as /asset_report or /asset_report/pdf to fetch an Asset Report.
     * @type {string}
     * @memberof CreateAssetReportResponse
     */
    'asset_report_token'?: string;
    /**
     * A unique ID identifying an Asset Report. 
     * @type {string}
     * @memberof CreateAssetReportResponse
     */
    'asset_report_id'?: string;
}
/**
 * 
 * @export
 * @interface CreateEntityRequest
 */
export interface CreateEntityRequest {
    /**
     * Id of the entity
     * @type {string}
     * @memberof CreateEntityRequest
     */
    'id'?: string;
    /**
     * Email of the entity
     * @type {string}
     * @memberof CreateEntityRequest
     */
    'email'?: string;
    /**
     * These will force the user to connect through all of these aggregators
     * @type {Array<Aggregator>}
     * @memberof CreateEntityRequest
     */
    'aggregators'?: Array<Aggregator>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateEntityRequest
     */
    'institution_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateEntityResponse
 */
export interface CreateEntityResponse {
    /**
     * Id of the entity
     * @type {string}
     * @memberof CreateEntityResponse
     */
    'id'?: string;
    /**
     * Email of the entity
     * @type {string}
     * @memberof CreateEntityResponse
     */
    'email'?: string;
    /**
     * These will force the user to connect through all of these aggregators
     * @type {Array<Aggregator>}
     * @memberof CreateEntityResponse
     */
    'aggregators'?: Array<Aggregator>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateEntityResponse
     */
    'institution_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateLinkTokenRequest
 */
export interface CreateLinkTokenRequest {
    /**
     * An id that is unique for an institution.
     * @type {string}
     * @memberof CreateLinkTokenRequest
     */
    'institution_id'?: string;
    /**
     * Unique identifier for the user or business account.
     * @type {string}
     * @memberof CreateLinkTokenRequest
     */
    'entity_id': string;
    /**
     * The name of the user or business account.
     * @type {string}
     * @memberof CreateLinkTokenRequest
     */
    'entity_name'?: string;
    /**
     * Email address associated with the user or business account.
     * @type {string}
     * @memberof CreateLinkTokenRequest
     */
    'entity_email'?: string;
    /**
     * This field is used to provide the user with a link to reconnect their financial account. It may be included in an automated email sent by Fuse to the entity\'s registered email address. It\'s important to note that the reconnection_url should be a valid URL and can only be used once to reconnect the disconnected account.
     * @type {string}
     * @memberof CreateLinkTokenRequest
     */
    'reconnection_url'?: string;
    /**
     * The name of your application.
     * @type {string}
     * @memberof CreateLinkTokenRequest
     */
    'client_name'?: string;
    /**
     * The session client secret created from the \'Create session client secret\' endpoint
     * @type {string}
     * @memberof CreateLinkTokenRequest
     */
    'session_client_secret': string;
    /**
     * 
     * @type {CreateLinkTokenRequestMx}
     * @memberof CreateLinkTokenRequest
     */
    'mx'?: CreateLinkTokenRequestMx;
    /**
     * 
     * @type {CreateLinkTokenRequestPlaid}
     * @memberof CreateLinkTokenRequest
     */
    'plaid'?: CreateLinkTokenRequestPlaid;
}
/**
 * An object specifying information about the MX configuration to use for deciding which MX supported financial institutions to display.
 * @export
 * @interface CreateLinkTokenRequestMx
 */
export interface CreateLinkTokenRequestMx {
    /**
     * Follows the same schema as MX\'s request a connect url(https://docs.mx.com/api#connect_request_a_url) schema.
     * @type {object}
     * @memberof CreateLinkTokenRequestMx
     */
    'config'?: object;
}
/**
 * An object specifying information about the Plaid configuration to use when creating a link token. 
 * @export
 * @interface CreateLinkTokenRequestPlaid
 */
export interface CreateLinkTokenRequestPlaid {
    /**
     * Follows the same schema as Plaid\'s Link Token Create Schema(https://plaid.com/docs/api/tokens/#linktokencreate). \'products\', \'client_id\', \'secret\', \'client_user_id\', \'client_name\', \'webhook\', \'institution_data\' and \'country_codes\' (only US supported right now) will be set by Fuse and override any values you set.
     * @type {object}
     * @memberof CreateLinkTokenRequestPlaid
     */
    'config'?: object;
}
/**
 * 
 * @export
 * @interface CreateLinkTokenResponse
 */
export interface CreateLinkTokenResponse {
    /**
     * Token needed by the frontend sdk to initiate the connection
     * @type {string}
     * @memberof CreateLinkTokenResponse
     */
    'link_token'?: string;
    /**
     * Used for debugging purposes
     * @type {string}
     * @memberof CreateLinkTokenResponse
     */
    'request_id'?: string;
}
/**
 * 
 * @export
 * @interface CreateSessionRequest
 */
export interface CreateSessionRequest {
    /**
     * 
     * @type {Array<Aggregator>}
     * @memberof CreateSessionRequest
     */
    'supported_financial_institution_aggregators'?: Array<Aggregator>;
    /**
     * List of products that you would like the institutions to support
     * @type {Array<Product>}
     * @memberof CreateSessionRequest
     */
    'products'?: Array<Product>;
}
/**
 * 
 * @export
 * @interface CreateSessionResponse
 */
export interface CreateSessionResponse {
    /**
     * 4 hours from the point of creation
     * @type {string}
     * @memberof CreateSessionResponse
     */
    'expiration'?: string;
    /**
     * Token needed by the frontend sdk to start the process
     * @type {string}
     * @memberof CreateSessionResponse
     */
    'client_secret'?: string;
    /**
     * Used for debugging purposes
     * @type {string}
     * @memberof CreateSessionResponse
     */
    'request_id'?: string;
}
/**
 * 
 * @export
 * @interface ExchangeFinancialConnectionsPublicTokenRequest
 */
export interface ExchangeFinancialConnectionsPublicTokenRequest {
    /**
     * The public token created after a user connects with their financial institution
     * @type {string}
     * @memberof ExchangeFinancialConnectionsPublicTokenRequest
     */
    'public_token'?: string;
}
/**
 * 
 * @export
 * @interface ExchangeFinancialConnectionsPublicTokenResponse
 */
export interface ExchangeFinancialConnectionsPublicTokenResponse {
    /**
     * Token used for querying data on the user
     * @type {string}
     * @memberof ExchangeFinancialConnectionsPublicTokenResponse
     */
    'access_token'?: string;
    /**
     * The id of the new financial connection. Every webhook will be sent with this id.
     * @type {string}
     * @memberof ExchangeFinancialConnectionsPublicTokenResponse
     */
    'financial_connection_id'?: string;
    /**
     * Used for debugging purposes
     * @type {string}
     * @memberof ExchangeFinancialConnectionsPublicTokenResponse
     */
    'request_id'?: string;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsAccount
 */
export interface FinancialConnectionsAccount {
    /**
     * Remote Id of the account, ie Plaid or Teller account id
     * @type {string}
     * @memberof FinancialConnectionsAccount
     */
    'remote_id'?: string;
    /**
     * Uniquely identifies this account across all accounts associated with your organization. See more information here: https://letsfuse.readme.io/docs/duplicate-accounts
     * @type {string}
     * @memberof FinancialConnectionsAccount
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {FinancialConnectionsAccountInstitution}
     * @memberof FinancialConnectionsAccount
     */
    'institution'?: FinancialConnectionsAccountInstitution;
    /**
     * The last four digits of the account number.
     * @type {string}
     * @memberof FinancialConnectionsAccount
     */
    'last_four'?: string;
    /**
     * The account\'s name, ie \'My Checking\'
     * @type {string}
     * @memberof FinancialConnectionsAccount
     */
    'name'?: string;
    /**
     * The account\'s type e.g depository.
     * @type {string}
     * @memberof FinancialConnectionsAccount
     */
    'type'?: string;
    /**
     * The account\'s subtype
     * @type {string}
     * @memberof FinancialConnectionsAccount
     */
    'subtype'?: string;
    /**
     * 
     * @type {FinancialConnectionsAccountBalance}
     * @memberof FinancialConnectionsAccount
     */
    'balance'?: FinancialConnectionsAccountBalance;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsAccountBalance
 */
export interface FinancialConnectionsAccountBalance {
    /**
     * The amount of funds available to be withdrawn from the account, as determined by the financial institution Available balance may be cached and is not guaranteed to be up-to-date in realtime unless the value was returned by /financial_connections/balances.
     * @type {string}
     * @memberof FinancialConnectionsAccountBalance
     */
    'available'?: string;
    /**
     * Amount without factoring in pending balances
     * @type {number}
     * @memberof FinancialConnectionsAccountBalance
     */
    'current'?: number;
    /**
     * The ISO-4217 currency code of the balance.
     * @type {string}
     * @memberof FinancialConnectionsAccountBalance
     */
    'iso_currency_code'?: string;
    /**
     * The date of the last update to the balance.
     * @type {string}
     * @memberof FinancialConnectionsAccountBalance
     */
    'last_updated_date'?: string;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsAccountDetails
 */
export interface FinancialConnectionsAccountDetails {
    /**
     * Remote Id of the account, ie Plaid or Teller account id
     * @type {string}
     * @memberof FinancialConnectionsAccountDetails
     */
    'remote_id'?: string;
    /**
     * 
     * @type {FinancialConnectionsAccountDetailsAch}
     * @memberof FinancialConnectionsAccountDetails
     */
    'ach'?: FinancialConnectionsAccountDetailsAch;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsAccountDetailsAch
 */
export interface FinancialConnectionsAccountDetailsAch {
    /**
     * Account number
     * @type {string}
     * @memberof FinancialConnectionsAccountDetailsAch
     */
    'account'?: string;
    /**
     * Routing number
     * @type {string}
     * @memberof FinancialConnectionsAccountDetailsAch
     */
    'routing'?: string;
    /**
     * Wire routing number
     * @type {string}
     * @memberof FinancialConnectionsAccountDetailsAch
     */
    'wire_routing'?: string;
    /**
     * BACS routing number
     * @type {string}
     * @memberof FinancialConnectionsAccountDetailsAch
     */
    'bacs_routing'?: string;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsAccountInstitution
 */
export interface FinancialConnectionsAccountInstitution {
    /**
     * 
     * @type {string}
     * @memberof FinancialConnectionsAccountInstitution
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsAccountLiability
 */
export interface FinancialConnectionsAccountLiability {
    /**
     * Remote Id of the account, ie Plaid or Teller account id
     * @type {string}
     * @memberof FinancialConnectionsAccountLiability
     */
    'remote_id'?: string;
    /**
     * Uniquely identifies this account across all accounts associated with your organization. See more information here: https://letsfuse.readme.io/docs/duplicate-accounts
     * @type {string}
     * @memberof FinancialConnectionsAccountLiability
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {FinancialConnectionsAccountInstitution}
     * @memberof FinancialConnectionsAccountLiability
     */
    'institution'?: FinancialConnectionsAccountInstitution;
    /**
     * The last four digits of the account number.
     * @type {string}
     * @memberof FinancialConnectionsAccountLiability
     */
    'last_four'?: string;
    /**
     * The account\'s name, ie \'My Checking\'
     * @type {string}
     * @memberof FinancialConnectionsAccountLiability
     */
    'name'?: string;
    /**
     * The account\'s type e.g depository.
     * @type {string}
     * @memberof FinancialConnectionsAccountLiability
     */
    'type'?: string;
    /**
     * The account\'s subtype
     * @type {string}
     * @memberof FinancialConnectionsAccountLiability
     */
    'subtype'?: string;
    /**
     * 
     * @type {FinancialConnectionsAccountBalance}
     * @memberof FinancialConnectionsAccountLiability
     */
    'balance'?: FinancialConnectionsAccountBalance;
    /**
     * The various interest rates that apply to the account. If APR data is not available, this array will be empty.
     * @type {Array<FinancialConnectionsAccountLiabilityAllOfAprs>}
     * @memberof FinancialConnectionsAccountLiability
     */
    'aprs'?: Array<FinancialConnectionsAccountLiabilityAllOfAprs>;
    /**
     * The interest rate on the loan as a percentage.
     * @type {number}
     * @memberof FinancialConnectionsAccountLiability
     */
    'interest_rate_percentage'?: number;
    /**
     * The original principal balance of the loan.
     * @type {number}
     * @memberof FinancialConnectionsAccountLiability
     */
    'origination_principal_amount'?: number;
    /**
     * The due date for the next payment. The due date is null if a payment is not expected.
     * @type {string}
     * @memberof FinancialConnectionsAccountLiability
     */
    'next_payment_due_date'?: string;
    /**
     * The date of the last payment. Dates are returned in an ISO 8601 format (YYYY-MM-DD).
     * @type {string}
     * @memberof FinancialConnectionsAccountLiability
     */
    'last_payment_date'?: string;
    /**
     * The amount of the last payment.
     * @type {number}
     * @memberof FinancialConnectionsAccountLiability
     */
    'last_payment_amount'?: number;
    /**
     * The minimum payment required for an account. This can apply to any debt account.
     * @type {number}
     * @memberof FinancialConnectionsAccountLiability
     */
    'minimum_payment_amount'?: number;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsAccountLiabilityAllOf
 */
export interface FinancialConnectionsAccountLiabilityAllOf {
    /**
     * The various interest rates that apply to the account. If APR data is not available, this array will be empty.
     * @type {Array<FinancialConnectionsAccountLiabilityAllOfAprs>}
     * @memberof FinancialConnectionsAccountLiabilityAllOf
     */
    'aprs'?: Array<FinancialConnectionsAccountLiabilityAllOfAprs>;
    /**
     * The interest rate on the loan as a percentage.
     * @type {number}
     * @memberof FinancialConnectionsAccountLiabilityAllOf
     */
    'interest_rate_percentage'?: number;
    /**
     * The original principal balance of the loan.
     * @type {number}
     * @memberof FinancialConnectionsAccountLiabilityAllOf
     */
    'origination_principal_amount'?: number;
    /**
     * The due date for the next payment. The due date is null if a payment is not expected.
     * @type {string}
     * @memberof FinancialConnectionsAccountLiabilityAllOf
     */
    'next_payment_due_date'?: string;
    /**
     * The date of the last payment. Dates are returned in an ISO 8601 format (YYYY-MM-DD).
     * @type {string}
     * @memberof FinancialConnectionsAccountLiabilityAllOf
     */
    'last_payment_date'?: string;
    /**
     * The amount of the last payment.
     * @type {number}
     * @memberof FinancialConnectionsAccountLiabilityAllOf
     */
    'last_payment_amount'?: number;
    /**
     * The minimum payment required for an account. This can apply to any debt account.
     * @type {number}
     * @memberof FinancialConnectionsAccountLiabilityAllOf
     */
    'minimum_payment_amount'?: number;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsAccountLiabilityAllOfAprs
 */
export interface FinancialConnectionsAccountLiabilityAllOfAprs {
    /**
     * Annual Percentage Rate applied.
     * @type {number}
     * @memberof FinancialConnectionsAccountLiabilityAllOfAprs
     */
    'apr_percentage'?: number;
    /**
     * The type of balance to which the APR applies.
     * @type {string}
     * @memberof FinancialConnectionsAccountLiabilityAllOfAprs
     */
    'apr_type'?: string;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsHolding
 */
export interface FinancialConnectionsHolding {
    /**
     * Remote account id associated with this holding
     * @type {string}
     * @memberof FinancialConnectionsHolding
     */
    'remote_account_id'?: string;
    /**
     * The original total value of the holding.
     * @type {number}
     * @memberof FinancialConnectionsHolding
     */
    'cost_basis'?: number;
    /**
     * The value of the holding
     * @type {number}
     * @memberof FinancialConnectionsHolding
     */
    'value'?: number;
    /**
     * The ISO-4217 currency code of the holding.
     * @type {string}
     * @memberof FinancialConnectionsHolding
     */
    'iso_currency_code'?: string;
    /**
     * The number of units of the security involved in this transaction.
     * @type {number}
     * @memberof FinancialConnectionsHolding
     */
    'quantity'?: number;
    /**
     * The security_id associated with the holding.
     * @type {string}
     * @memberof FinancialConnectionsHolding
     */
    'security_id'?: string;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsInvestmentAccount
 */
export interface FinancialConnectionsInvestmentAccount {
    /**
     * Remote Id of the account, ie Plaid or Teller account id
     * @type {string}
     * @memberof FinancialConnectionsInvestmentAccount
     */
    'remote_id'?: string;
    /**
     * Uniquely identifies this account across all accounts associated with your organization. See more information here: https://letsfuse.readme.io/docs/duplicate-accounts
     * @type {string}
     * @memberof FinancialConnectionsInvestmentAccount
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {FinancialConnectionsAccountInstitution}
     * @memberof FinancialConnectionsInvestmentAccount
     */
    'institution'?: FinancialConnectionsAccountInstitution;
    /**
     * The last four digits of the account number.
     * @type {string}
     * @memberof FinancialConnectionsInvestmentAccount
     */
    'last_four'?: string;
    /**
     * The account\'s name, ie \'My Checking\'
     * @type {string}
     * @memberof FinancialConnectionsInvestmentAccount
     */
    'name'?: string;
    /**
     * The account\'s type e.g depository.
     * @type {string}
     * @memberof FinancialConnectionsInvestmentAccount
     */
    'type'?: string;
    /**
     * The account\'s subtype e.g checking
     * @type {string}
     * @memberof FinancialConnectionsInvestmentAccount
     */
    'subtype'?: string;
    /**
     * 
     * @type {FinancialConnectionsAccountBalance}
     * @memberof FinancialConnectionsInvestmentAccount
     */
    'balance'?: FinancialConnectionsAccountBalance;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsInvestmentSecurity
 */
export interface FinancialConnectionsInvestmentSecurity {
    /**
     * The security type of the holding.
     * @type {string}
     * @memberof FinancialConnectionsInvestmentSecurity
     */
    'type'?: string;
    /**
     * 9-character CUSIP, an identifier assigned to North American securities.
     * @type {string}
     * @memberof FinancialConnectionsInvestmentSecurity
     */
    'cusip'?: string;
    /**
     * A descriptive name for the security, suitable for display.
     * @type {string}
     * @memberof FinancialConnectionsInvestmentSecurity
     */
    'name'?: string;
    /**
     * The security’s trading symbol for publicly traded securities, and otherwise a short identifier if available.
     * @type {string}
     * @memberof FinancialConnectionsInvestmentSecurity
     */
    'ticker_symbol'?: string;
    /**
     * A unique identity for the security
     * @type {string}
     * @memberof FinancialConnectionsInvestmentSecurity
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsInvestmentTransaction
 */
export interface FinancialConnectionsInvestmentTransaction {
    /**
     * 
     * @type {Array<FinancialConnectionsInvestmentTransactionDataInner>}
     * @memberof FinancialConnectionsInvestmentTransaction
     */
    'data'?: Array<FinancialConnectionsInvestmentTransactionDataInner>;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsInvestmentTransactionDataInner
 */
export interface FinancialConnectionsInvestmentTransactionDataInner {
    /**
     * Fuse Id of the investment transaction
     * @type {string}
     * @memberof FinancialConnectionsInvestmentTransactionDataInner
     */
    'id'?: string;
    /**
     * The remote ID of the Investment transaction
     * @type {string}
     * @memberof FinancialConnectionsInvestmentTransactionDataInner
     */
    'remote_investment_transaction_id'?: string;
    /**
     * Remote Account Id of the transaction, ie Plaid Account Id
     * @type {string}
     * @memberof FinancialConnectionsInvestmentTransactionDataInner
     */
    'remote_account_id'?: string;
    /**
     * The complete value of the transaction. Positive values when cash is debited, e.g. purchases of stock; negative values when cash is credited, e.g. sales of stock.
     * @type {number}
     * @memberof FinancialConnectionsInvestmentTransactionDataInner
     */
    'amount'?: number;
    /**
     * The number of units of the security involved in this transaction. Positive for buy transactions; negative for sell transactions.
     * @type {string}
     * @memberof FinancialConnectionsInvestmentTransactionDataInner
     */
    'quantity'?: string;
    /**
     * The institution’s description of the transaction.
     * @type {string}
     * @memberof FinancialConnectionsInvestmentTransactionDataInner
     */
    'name'?: string;
    /**
     * Type of the transaction, ie buy, sell
     * @type {string}
     * @memberof FinancialConnectionsInvestmentTransactionDataInner
     */
    'type'?: string;
    /**
     * Date of the transaction
     * @type {string}
     * @memberof FinancialConnectionsInvestmentTransactionDataInner
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsOwner
 */
export interface FinancialConnectionsOwner {
    /**
     * 
     * @type {Array<FinancialConnectionsOwnerAddressesInner>}
     * @memberof FinancialConnectionsOwner
     */
    'addresses'?: Array<FinancialConnectionsOwnerAddressesInner>;
    /**
     * 
     * @type {Array<FinancialConnectionsOwnerEmailsInner>}
     * @memberof FinancialConnectionsOwner
     */
    'emails'?: Array<FinancialConnectionsOwnerEmailsInner>;
    /**
     * List of names associated with the owner
     * @type {Array<FinancialConnectionsOwnerNamesInner>}
     * @memberof FinancialConnectionsOwner
     */
    'names'?: Array<FinancialConnectionsOwnerNamesInner>;
    /**
     * 
     * @type {Array<FinancialConnectionsOwnerPhoneNumbersInner>}
     * @memberof FinancialConnectionsOwner
     */
    'phone_numbers'?: Array<FinancialConnectionsOwnerPhoneNumbersInner>;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsOwnerAddressesInner
 */
export interface FinancialConnectionsOwnerAddressesInner {
    /**
     * 
     * @type {FinancialConnectionsOwnerAddressesInnerData}
     * @memberof FinancialConnectionsOwnerAddressesInner
     */
    'data'?: FinancialConnectionsOwnerAddressesInnerData;
    /**
     * Indicating if it is the primary address
     * @type {boolean}
     * @memberof FinancialConnectionsOwnerAddressesInner
     */
    'primary'?: boolean;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsOwnerAddressesInnerData
 */
export interface FinancialConnectionsOwnerAddressesInnerData {
    /**
     * City of the address
     * @type {string}
     * @memberof FinancialConnectionsOwnerAddressesInnerData
     */
    'city'?: string;
    /**
     * Country of the address
     * @type {string}
     * @memberof FinancialConnectionsOwnerAddressesInnerData
     */
    'country'?: string;
    /**
     * Postal code of the address
     * @type {string}
     * @memberof FinancialConnectionsOwnerAddressesInnerData
     */
    'postal_code'?: string;
    /**
     * Region of the address
     * @type {string}
     * @memberof FinancialConnectionsOwnerAddressesInnerData
     */
    'region'?: string;
    /**
     * Street of the address
     * @type {string}
     * @memberof FinancialConnectionsOwnerAddressesInnerData
     */
    'street'?: string;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsOwnerEmailsInner
 */
export interface FinancialConnectionsOwnerEmailsInner {
    /**
     * Email address
     * @type {string}
     * @memberof FinancialConnectionsOwnerEmailsInner
     */
    'data'?: string;
    /**
     * Indicating if it is the primary email
     * @type {boolean}
     * @memberof FinancialConnectionsOwnerEmailsInner
     */
    'primary'?: boolean;
    /**
     * Type of the email
     * @type {string}
     * @memberof FinancialConnectionsOwnerEmailsInner
     */
    'type'?: FinancialConnectionsOwnerEmailsInnerTypeEnum;
}

export const FinancialConnectionsOwnerEmailsInnerTypeEnum = {
    Primary: 'primary',
    Secondary: 'secondary',
    Other: 'other'
} as const;

export type FinancialConnectionsOwnerEmailsInnerTypeEnum = typeof FinancialConnectionsOwnerEmailsInnerTypeEnum[keyof typeof FinancialConnectionsOwnerEmailsInnerTypeEnum];

/**
 * 
 * @export
 * @interface FinancialConnectionsOwnerNamesInner
 */
export interface FinancialConnectionsOwnerNamesInner {
    /**
     * Name of the owner
     * @type {string}
     * @memberof FinancialConnectionsOwnerNamesInner
     */
    'data'?: string;
    /**
     * Type of name. Possible values are \"name\" or \"alias\"
     * @type {string}
     * @memberof FinancialConnectionsOwnerNamesInner
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface FinancialConnectionsOwnerPhoneNumbersInner
 */
export interface FinancialConnectionsOwnerPhoneNumbersInner {
    /**
     * The phone number
     * @type {string}
     * @memberof FinancialConnectionsOwnerPhoneNumbersInner
     */
    'data'?: string;
    /**
     * Indicating if it is the primary phone number
     * @type {boolean}
     * @memberof FinancialConnectionsOwnerPhoneNumbersInner
     */
    'primary'?: boolean;
    /**
     * Type of the phone number
     * @type {string}
     * @memberof FinancialConnectionsOwnerPhoneNumbersInner
     */
    'type'?: FinancialConnectionsOwnerPhoneNumbersInnerTypeEnum;
}

export const FinancialConnectionsOwnerPhoneNumbersInnerTypeEnum = {
    Home: 'home',
    Work: 'work',
    Mobile: 'mobile'
} as const;

export type FinancialConnectionsOwnerPhoneNumbersInnerTypeEnum = typeof FinancialConnectionsOwnerPhoneNumbersInnerTypeEnum[keyof typeof FinancialConnectionsOwnerPhoneNumbersInnerTypeEnum];

/**
 * 
 * @export
 * @interface FuseApiError
 */
export interface FuseApiError {
    /**
     * 
     * @type {string}
     * @memberof FuseApiError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof FuseApiError
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof FuseApiError
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof FuseApiError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof FuseApiError
     */
    'source'?: FuseApiErrorSourceEnum;
    /**
     * 
     * @type {FuseApiErrorData}
     * @memberof FuseApiError
     */
    'data'?: FuseApiErrorData;
}

export const FuseApiErrorSourceEnum = {
    Internal: 'internal',
    Aggregator: 'aggregator'
} as const;

export type FuseApiErrorSourceEnum = typeof FuseApiErrorSourceEnum[keyof typeof FuseApiErrorSourceEnum];

/**
 * 
 * @export
 * @interface FuseApiErrorData
 */
export interface FuseApiErrorData {
    /**
     * 
     * @type {string}
     * @memberof FuseApiErrorData
     */
    'aggregator'?: string;
    /**
     * 
     * @type {Array<FuseApiError>}
     * @memberof FuseApiErrorData
     */
    'errors'?: Array<FuseApiError>;
}
/**
 * 
 * @export
 * @interface FuseApiWarning
 */
export interface FuseApiWarning {
    /**
     * 
     * @type {string}
     * @memberof FuseApiWarning
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof FuseApiWarning
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof FuseApiWarning
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof FuseApiWarning
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof FuseApiWarning
     */
    'source'?: FuseApiWarningSourceEnum;
    /**
     * 
     * @type {FuseApiWarningData}
     * @memberof FuseApiWarning
     */
    'data'?: FuseApiWarningData;
}

export const FuseApiWarningSourceEnum = {
    Internal: 'internal',
    Aggregator: 'aggregator'
} as const;

export type FuseApiWarningSourceEnum = typeof FuseApiWarningSourceEnum[keyof typeof FuseApiWarningSourceEnum];

/**
 * 
 * @export
 * @interface FuseApiWarningData
 */
export interface FuseApiWarningData {
    /**
     * 
     * @type {string}
     * @memberof FuseApiWarningData
     */
    'aggregator'?: string;
    /**
     * 
     * @type {Array<FuseApiWarningDataWarningsInner>}
     * @memberof FuseApiWarningData
     */
    'warnings'?: Array<FuseApiWarningDataWarningsInner>;
}
/**
 * 
 * @export
 * @interface FuseApiWarningDataWarningsInner
 */
export interface FuseApiWarningDataWarningsInner {
    /**
     * 
     * @type {string}
     * @memberof FuseApiWarningDataWarningsInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof FuseApiWarningDataWarningsInner
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof FuseApiWarningDataWarningsInner
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof FuseApiWarningDataWarningsInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof FuseApiWarningDataWarningsInner
     */
    'source'?: FuseApiWarningDataWarningsInnerSourceEnum;
}

export const FuseApiWarningDataWarningsInnerSourceEnum = {
    Internal: 'internal',
    Aggregator: 'aggregator'
} as const;

export type FuseApiWarningDataWarningsInnerSourceEnum = typeof FuseApiWarningDataWarningsInnerSourceEnum[keyof typeof FuseApiWarningDataWarningsInnerSourceEnum];

/**
 * 
 * @export
 * @interface GetAssetReportRequest
 */
export interface GetAssetReportRequest {
    /**
     * The token associated with the Asset Report to retrieve.
     * @type {string}
     * @memberof GetAssetReportRequest
     */
    'asset_report_token': string;
}
/**
 * 
 * @export
 * @interface GetAssetReportResponse
 */
export interface GetAssetReportResponse {
    /**
     * 
     * @type {GetAssetReportResponseReport}
     * @memberof GetAssetReportResponse
     */
    'report'?: GetAssetReportResponseReport;
}
/**
 * The Asset Report in JSON format.
 * @export
 * @interface GetAssetReportResponseReport
 */
export interface GetAssetReportResponseReport {
    /**
     * A unique ID identifying an Asset Report.
     * @type {string}
     * @memberof GetAssetReportResponseReport
     */
    'asset_report_id'?: string;
    /**
     * An identifier you determine and submit for the Asset Report. 
     * @type {string}
     * @memberof GetAssetReportResponseReport
     */
    'client_report_id'?: string;
    /**
     * The date and time when the Asset Report was created, in ISO 8601 format
     * @type {string}
     * @memberof GetAssetReportResponseReport
     */
    'date_generated'?: string;
    /**
     * The duration of transaction history you requested
     * @type {number}
     * @memberof GetAssetReportResponseReport
     */
    'days_requested'?: number;
    /**
     * An array of Asset Reports, one for each account in the Asset Report.
     * @type {Array<GetAssetReportResponseReportAccountsInner>}
     * @memberof GetAssetReportResponseReport
     */
    'accounts'?: Array<GetAssetReportResponseReportAccountsInner>;
    /**
     * If the Asset Report generation was successful but identity information cannot be returned, this array will contain information about the errors causing identity information to be missing
     * @type {Array<FuseApiWarning>}
     * @memberof GetAssetReportResponseReport
     */
    'warnings'?: Array<FuseApiWarning>;
}
/**
 * 
 * @export
 * @interface GetAssetReportResponseReportAccountsInner
 */
export interface GetAssetReportResponseReportAccountsInner {
    /**
     * \"The remote account ID of the account.\",
     * @type {string}
     * @memberof GetAssetReportResponseReportAccountsInner
     */
    'remote_account_id'?: string;
    /**
     * 
     * @type {GetAssetReportResponseReportAccountsInnerBalances}
     * @memberof GetAssetReportResponseReportAccountsInner
     */
    'balances'?: GetAssetReportResponseReportAccountsInnerBalances;
    /**
     * An array of historical balances for the account.
     * @type {Array<GetAssetReportResponseReportAccountsInnerHistoricalBalancesInner>}
     * @memberof GetAssetReportResponseReportAccountsInner
     */
    'historical_balances'?: Array<GetAssetReportResponseReportAccountsInnerHistoricalBalancesInner>;
    /**
     * 
     * @type {Array<FinancialConnectionsOwner>}
     * @memberof GetAssetReportResponseReportAccountsInner
     */
    'owners'?: Array<FinancialConnectionsOwner>;
}
/**
 * 
 * @export
 * @interface GetAssetReportResponseReportAccountsInnerBalances
 */
export interface GetAssetReportResponseReportAccountsInnerBalances {
    /**
     * Amount after factoring in pending balances
     * @type {number}
     * @memberof GetAssetReportResponseReportAccountsInnerBalances
     */
    'available'?: number;
    /**
     * Amount without factoring in pending balances
     * @type {number}
     * @memberof GetAssetReportResponseReportAccountsInnerBalances
     */
    'current'?: number;
    /**
     * The ISO-4217 currency code of the balance.
     * @type {string}
     * @memberof GetAssetReportResponseReportAccountsInnerBalances
     */
    'iso_currency_code'?: string;
}
/**
 * 
 * @export
 * @interface GetAssetReportResponseReportAccountsInnerHistoricalBalancesInner
 */
export interface GetAssetReportResponseReportAccountsInnerHistoricalBalancesInner {
    /**
     * The date of the calculated historical balance, in an ISO 8601 format (YYYY-MM-DD)
     * @type {string}
     * @memberof GetAssetReportResponseReportAccountsInnerHistoricalBalancesInner
     */
    'date'?: string;
    /**
     * The total amount of funds in the account, calculated from the current balance in the balance object by subtracting inflows and adding back outflows according to the posted date of each transaction.
     * @type {number}
     * @memberof GetAssetReportResponseReportAccountsInnerHistoricalBalancesInner
     */
    'current'?: number;
    /**
     * The ISO-4217 currency code of the balance.
     * @type {string}
     * @memberof GetAssetReportResponseReportAccountsInnerHistoricalBalancesInner
     */
    'iso_currency_code'?: string;
}
/**
 * 
 * @export
 * @interface GetEntityResponse
 */
export interface GetEntityResponse {
    /**
     * Id of the entity
     * @type {string}
     * @memberof GetEntityResponse
     */
    'id'?: string;
    /**
     * Email of the entity
     * @type {string}
     * @memberof GetEntityResponse
     */
    'email'?: string;
    /**
     * These will force the user to connect through all of these aggregators
     * @type {Array<Aggregator>}
     * @memberof GetEntityResponse
     */
    'aggregators'?: Array<Aggregator>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetEntityResponse
     */
    'institution_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetFinancialConnectionsAccountBalanceResponse
 */
export interface GetFinancialConnectionsAccountBalanceResponse {
    /**
     * 
     * @type {Array<FinancialConnectionsAccountBalance>}
     * @memberof GetFinancialConnectionsAccountBalanceResponse
     */
    'balances'?: Array<FinancialConnectionsAccountBalance>;
}
/**
 * 
 * @export
 * @interface GetFinancialConnectionsAccountDetailsRequest
 */
export interface GetFinancialConnectionsAccountDetailsRequest {
    /**
     * Access token for authentication
     * @type {string}
     * @memberof GetFinancialConnectionsAccountDetailsRequest
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface GetFinancialConnectionsAccountDetailsResponse
 */
export interface GetFinancialConnectionsAccountDetailsResponse {
    /**
     * 
     * @type {Array<FinancialConnectionsAccountDetails>}
     * @memberof GetFinancialConnectionsAccountDetailsResponse
     */
    'account_details'?: Array<FinancialConnectionsAccountDetails>;
}
/**
 * 
 * @export
 * @interface GetFinancialConnectionsAccountsRequest
 */
export interface GetFinancialConnectionsAccountsRequest {
    /**
     * Access token for authentication
     * @type {string}
     * @memberof GetFinancialConnectionsAccountsRequest
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface GetFinancialConnectionsAccountsResponse
 */
export interface GetFinancialConnectionsAccountsResponse {
    /**
     * 
     * @type {Array<FinancialConnectionsAccount>}
     * @memberof GetFinancialConnectionsAccountsResponse
     */
    'accounts'?: Array<FinancialConnectionsAccount>;
}
/**
 * 
 * @export
 * @interface GetFinancialConnectionsBalanceRequest
 */
export interface GetFinancialConnectionsBalanceRequest {
    /**
     * Access token for authentication
     * @type {string}
     * @memberof GetFinancialConnectionsBalanceRequest
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface GetFinancialConnectionsOwnersRequest
 */
export interface GetFinancialConnectionsOwnersRequest {
    /**
     * Access token for authentication
     * @type {string}
     * @memberof GetFinancialConnectionsOwnersRequest
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface GetFinancialConnectionsOwnersResponse
 */
export interface GetFinancialConnectionsOwnersResponse {
    /**
     * 
     * @type {Array<GetFinancialConnectionsOwnersResponseAccountsInner>}
     * @memberof GetFinancialConnectionsOwnersResponse
     */
    'accounts'?: Array<GetFinancialConnectionsOwnersResponseAccountsInner>;
}
/**
 * 
 * @export
 * @interface GetFinancialConnectionsOwnersResponseAccountsInner
 */
export interface GetFinancialConnectionsOwnersResponseAccountsInner {
    /**
     * The remote account id of the account
     * @type {string}
     * @memberof GetFinancialConnectionsOwnersResponseAccountsInner
     */
    'remote_account_id'?: string;
    /**
     * 
     * @type {Array<FinancialConnectionsOwner>}
     * @memberof GetFinancialConnectionsOwnersResponseAccountsInner
     */
    'owners'?: Array<FinancialConnectionsOwner>;
}
/**
 * 
 * @export
 * @interface GetInvestmentHoldingsRequest
 */
export interface GetInvestmentHoldingsRequest {
    /**
     * Access token for authentication
     * @type {string}
     * @memberof GetInvestmentHoldingsRequest
     */
    'access_token': string;
    /**
     * The ISO-4217 currency code to convert the holding to.
     * @type {string}
     * @memberof GetInvestmentHoldingsRequest
     */
    'iso_currency_code'?: string;
}
/**
 * 
 * @export
 * @interface GetInvestmentHoldingsResponse
 */
export interface GetInvestmentHoldingsResponse {
    /**
     * 
     * @type {Array<FinancialConnectionsInvestmentAccount>}
     * @memberof GetInvestmentHoldingsResponse
     */
    'accounts'?: Array<FinancialConnectionsInvestmentAccount>;
    /**
     * 
     * @type {Array<FinancialConnectionsHolding>}
     * @memberof GetInvestmentHoldingsResponse
     */
    'holdings'?: Array<FinancialConnectionsHolding>;
    /**
     * 
     * @type {Array<FinancialConnectionsInvestmentSecurity>}
     * @memberof GetInvestmentHoldingsResponse
     */
    'securities'?: Array<FinancialConnectionsInvestmentSecurity>;
}
/**
 * 
 * @export
 * @interface GetInvestmentTransactionsRequest
 */
export interface GetInvestmentTransactionsRequest {
    /**
     * Access token for authentication
     * @type {string}
     * @memberof GetInvestmentTransactionsRequest
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface GetInvestmentTransactionsResponse
 */
export interface GetInvestmentTransactionsResponse {
    /**
     * 
     * @type {Array<FinancialConnectionsInvestmentAccount>}
     * @memberof GetInvestmentTransactionsResponse
     */
    'accounts'?: Array<FinancialConnectionsInvestmentAccount>;
    /**
     * 
     * @type {Array<FinancialConnectionsInvestmentTransaction>}
     * @memberof GetInvestmentTransactionsResponse
     */
    'investment_transactions'?: Array<FinancialConnectionsInvestmentTransaction>;
    /**
     * 
     * @type {Array<FinancialConnectionsInvestmentSecurity>}
     * @memberof GetInvestmentTransactionsResponse
     */
    'securities'?: Array<FinancialConnectionsInvestmentSecurity>;
}
/**
 * 
 * @export
 * @interface GetLiabilitiesRequest
 */
export interface GetLiabilitiesRequest {
    /**
     * Access token for authentication
     * @type {string}
     * @memberof GetLiabilitiesRequest
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface GetLiabilitiesResponse
 */
export interface GetLiabilitiesResponse {
    /**
     * 
     * @type {Array<FinancialConnectionsAccountLiability>}
     * @memberof GetLiabilitiesResponse
     */
    'liabilities'?: Array<FinancialConnectionsAccountLiability>;
}
/**
 * 
 * @export
 * @interface GetTransactionsRequest
 */
export interface GetTransactionsRequest {
    /**
     * Access token for authentication
     * @type {string}
     * @memberof GetTransactionsRequest
     */
    'access_token': string;
    /**
     * Cursor for pagination
     * @type {string}
     * @memberof GetTransactionsRequest
     */
    'cursor'?: string;
    /**
     * Number of items per page
     * @type {number}
     * @memberof GetTransactionsRequest
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface GetTransactionsResponse
 */
export interface GetTransactionsResponse {
    /**
     * 
     * @type {Array<GetTransactionsResponseDataInner>}
     * @memberof GetTransactionsResponse
     */
    'data'?: Array<GetTransactionsResponseDataInner>;
    /**
     * The cursor of the last item returned
     * @type {string}
     * @memberof GetTransactionsResponse
     */
    'cursor'?: string;
    /**
     * Indicates if there are more pages to navigate through
     * @type {boolean}
     * @memberof GetTransactionsResponse
     */
    'has_next'?: boolean;
}
/**
 * 
 * @export
 * @interface GetTransactionsResponseDataInner
 */
export interface GetTransactionsResponseDataInner {
    /**
     * Fuse Id of the transaction
     * @type {string}
     * @memberof GetTransactionsResponseDataInner
     */
    'id'?: string;
    /**
     * Remote Id of the transaction, ie Plaid or Teller Id
     * @type {string}
     * @memberof GetTransactionsResponseDataInner
     */
    'remote_id'?: string;
    /**
     * Remote Account Id of the transaction, ie Plaid Account Id
     * @type {string}
     * @memberof GetTransactionsResponseDataInner
     */
    'remote_account_id'?: string;
    /**
     * Amount in cents associated with the transaction
     * @type {number}
     * @memberof GetTransactionsResponseDataInner
     */
    'amount'?: number;
    /**
     * Date of the transaction
     * @type {string}
     * @memberof GetTransactionsResponseDataInner
     */
    'date'?: string;
    /**
     * Description of the transaction
     * @type {string}
     * @memberof GetTransactionsResponseDataInner
     */
    'description'?: string;
    /**
     * Categories of the transaction, ie Computers and Electronics
     * @type {Array<string>}
     * @memberof GetTransactionsResponseDataInner
     */
    'category'?: Array<string>;
    /**
     * 
     * @type {GetTransactionsResponseDataInnerMerchant}
     * @memberof GetTransactionsResponseDataInner
     */
    'merchant'?: GetTransactionsResponseDataInnerMerchant;
    /**
     * The status of the transaction. This will be either POSTED or PENDING.
     * @type {string}
     * @memberof GetTransactionsResponseDataInner
     */
    'status'?: string;
    /**
     * Type of the transaction, ie adjustment
     * @type {string}
     * @memberof GetTransactionsResponseDataInner
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface GetTransactionsResponseDataInnerMerchant
 */
export interface GetTransactionsResponseDataInnerMerchant {
    /**
     * Merchant name
     * @type {string}
     * @memberof GetTransactionsResponseDataInnerMerchant
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Product = {
    AccountDetails: 'account_details',
    Balance: 'balance',
    Ownership: 'ownership',
    Transactions: 'transactions',
    Liabilities: 'liabilities',
    Investments: 'investments'
} as const;

export type Product = typeof Product[keyof typeof Product];


/**
 * 
 * @export
 * @interface RefreshAssetReportRequest
 */
export interface RefreshAssetReportRequest {
    /**
     * The asset_report_token returned by the original call to /asset_report/create
     * @type {string}
     * @memberof RefreshAssetReportRequest
     */
    'access_token'?: string;
    /**
     * The maximum integer number of days of history to include in the Asset Report
     * @type {number}
     * @memberof RefreshAssetReportRequest
     */
    'days_requested': number;
    /**
     * Indicates whether to include identity data in the Asset Report
     * @type {boolean}
     * @memberof RefreshAssetReportRequest
     */
    'include_identity'?: boolean;
}
/**
 * 
 * @export
 * @interface SyncFinancialConnectionsDataResponse
 */
export interface SyncFinancialConnectionsDataResponse {
    /**
     * Response message
     * @type {string}
     * @memberof SyncFinancialConnectionsDataResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface SyncTransactionsRequest
 */
export interface SyncTransactionsRequest {
    /**
     * The access token of the financial institution connection
     * @type {string}
     * @memberof SyncTransactionsRequest
     */
    'access_token': string;
    /**
     * The cursor value represents the last update requested. Providing it will cause the response to only return changes after this update. If omitted, the entire history of updates will be returned, starting with the first-added transactions on the item.
     * @type {string}
     * @memberof SyncTransactionsRequest
     */
    'cursor'?: string;
    /**
     * The number of transaction updates to fetch.
     * @type {number}
     * @memberof SyncTransactionsRequest
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface SyncTransactionsResponse
 */
export interface SyncTransactionsResponse {
    /**
     * Transactions that have been added to the item since `cursor` ordered by ascending last modified time.
     * @type {Array<TransactionCommonModel>}
     * @memberof SyncTransactionsResponse
     */
    'added'?: Array<TransactionCommonModel>;
    /**
     * Transactions that have been modified on the item since `cursor` ordered by ascending last modified time.
     * @type {Array<TransactionCommonModel>}
     * @memberof SyncTransactionsResponse
     */
    'modified'?: Array<TransactionCommonModel>;
    /**
     * Transactions that have been removed from the item since `cursor` ordered by ascending last modified time.
     * @type {Array<SyncTransactionsResponseRemovedInner>}
     * @memberof SyncTransactionsResponse
     */
    'removed'?: Array<SyncTransactionsResponseRemovedInner>;
    /**
     * Cursor used for fetching any future updates after the latest update provided in this response. The cursor obtained after all pages have been pulled (indicated by `has_next` being `false`) will be valid for at least 1 year. This cursor should be persisted for later calls.
     * @type {string}
     * @memberof SyncTransactionsResponse
     */
    'next_cursor'?: string;
    /**
     * Represents if more than requested count of transaction updates exist. If true, the additional updates can be fetched by making an additional request with `cursor` set to `next_cursor`. If `has_next` is true, it\'s important to pull all available pages, to make it less likely for underlying data changes to conflict with pagination.
     * @type {boolean}
     * @memberof SyncTransactionsResponse
     */
    'has_next'?: boolean;
}
/**
 * 
 * @export
 * @interface SyncTransactionsResponseRemovedInner
 */
export interface SyncTransactionsResponseRemovedInner {
    /**
     * 
     * @type {string}
     * @memberof SyncTransactionsResponseRemovedInner
     */
    'transaction_id'?: string;
}
/**
 * 
 * @export
 * @interface TransactionCommonModel
 */
export interface TransactionCommonModel {
    /**
     * 
     * @type {Array<GetTransactionsResponseDataInner>}
     * @memberof TransactionCommonModel
     */
    'data'?: Array<GetTransactionsResponseDataInner>;
}
/**
 * 
 * @export
 * @interface UpdateEntityRequest
 */
export interface UpdateEntityRequest {
    /**
     * Email of the entity
     * @type {string}
     * @memberof UpdateEntityRequest
     */
    'email'?: string;
    /**
     * These will force the user to connect through all of these aggregators
     * @type {Array<Aggregator>}
     * @memberof UpdateEntityRequest
     */
    'aggregators'?: Array<Aggregator>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateEntityRequest
     */
    'institution_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateEntityResponse
 */
export interface UpdateEntityResponse {
    /**
     * Id of the entity
     * @type {string}
     * @memberof UpdateEntityResponse
     */
    'id'?: string;
    /**
     * Email of the entity
     * @type {string}
     * @memberof UpdateEntityResponse
     */
    'email'?: string;
    /**
     * These will force the user to connect through all of these aggregators
     * @type {Array<Aggregator>}
     * @memberof UpdateEntityResponse
     */
    'aggregators'?: Array<Aggregator>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateEntityResponse
     */
    'institution_ids'?: Array<string>;
}

/**
 * FuseApi - axios parameter creator
 * @export
 */
export const FuseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to generate an Asset Report for a user.
         * @param {CreateAssetReportRequest} [createAssetReportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetReport: async (createAssetReportRequest?: CreateAssetReportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/asset_report/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAssetReportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create entity
         * @param {CreateEntityRequest} createEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntity: async (createEntityRequest: CreateEntityRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEntityRequest' is not null or undefined
            assertParamExists('createEntity', 'createEntityRequest', createEntityRequest)
            const localVarPath = `/v1/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEntityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a link token to start the process of a user connecting to a specific financial institution.
         * @param {CreateLinkTokenRequest} [createLinkTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLinkToken: async (createLinkTokenRequest?: CreateLinkTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/link/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLinkTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a session that returns a client_secret which is required as a parameter when initializing the Fuse SDK.
         * @param {CreateSessionRequest} [createSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession: async (createSessionRequest?: CreateSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API to exchange a public token for an access token and financial connection id
         * @param {ExchangeFinancialConnectionsPublicTokenRequest} [exchangeFinancialConnectionsPublicTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangeFinancialConnectionsPublicToken: async (exchangeFinancialConnectionsPublicTokenRequest?: ExchangeFinancialConnectionsPublicTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/financial_connections/public_token/exchange`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exchangeFinancialConnectionsPublicTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Asset Report in JSON format.
         * @param {GetAssetReportRequest} [getAssetReportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetReport: async (getAssetReportRequest?: GetAssetReportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/asset_report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAssetReportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity: async (entityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('getEntity', 'entityId', entityId)
            const localVarPath = `/v1/entities/{entity_id}`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account details
         * @param {GetFinancialConnectionsAccountDetailsRequest} getFinancialConnectionsAccountDetailsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinancialConnectionsAccountDetails: async (getFinancialConnectionsAccountDetailsRequest: GetFinancialConnectionsAccountDetailsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getFinancialConnectionsAccountDetailsRequest' is not null or undefined
            assertParamExists('getFinancialConnectionsAccountDetails', 'getFinancialConnectionsAccountDetailsRequest', getFinancialConnectionsAccountDetailsRequest)
            const localVarPath = `/v1/financial_connections/accounts/details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getFinancialConnectionsAccountDetailsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get accounts
         * @param {GetFinancialConnectionsAccountsRequest} getFinancialConnectionsAccountsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinancialConnectionsAccounts: async (getFinancialConnectionsAccountsRequest: GetFinancialConnectionsAccountsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getFinancialConnectionsAccountsRequest' is not null or undefined
            assertParamExists('getFinancialConnectionsAccounts', 'getFinancialConnectionsAccountsRequest', getFinancialConnectionsAccountsRequest)
            const localVarPath = `/v1/financial_connections/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getFinancialConnectionsAccountsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get balances
         * @param {GetFinancialConnectionsBalanceRequest} getFinancialConnectionsBalanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinancialConnectionsBalances: async (getFinancialConnectionsBalanceRequest: GetFinancialConnectionsBalanceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getFinancialConnectionsBalanceRequest' is not null or undefined
            assertParamExists('getFinancialConnectionsBalances', 'getFinancialConnectionsBalanceRequest', getFinancialConnectionsBalanceRequest)
            const localVarPath = `/v1/financial_connections/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getFinancialConnectionsBalanceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account owners
         * @param {GetFinancialConnectionsOwnersRequest} getFinancialConnectionsOwnersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinancialConnectionsOwners: async (getFinancialConnectionsOwnersRequest: GetFinancialConnectionsOwnersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getFinancialConnectionsOwnersRequest' is not null or undefined
            assertParamExists('getFinancialConnectionsOwners', 'getFinancialConnectionsOwnersRequest', getFinancialConnectionsOwnersRequest)
            const localVarPath = `/v1/financial_connections/owners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getFinancialConnectionsOwnersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transactions
         * @param {GetTransactionsRequest} getTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinancialConnectionsTransactions: async (getTransactionsRequest: GetTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getTransactionsRequest' is not null or undefined
            assertParamExists('getFinancialConnectionsTransactions', 'getTransactionsRequest', getTransactionsRequest)
            const localVarPath = `/v1/financial_connections/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get investment holdings
         * @param {GetInvestmentHoldingsRequest} getInvestmentHoldingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvestmentHoldings: async (getInvestmentHoldingsRequest: GetInvestmentHoldingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getInvestmentHoldingsRequest' is not null or undefined
            assertParamExists('getInvestmentHoldings', 'getInvestmentHoldingsRequest', getInvestmentHoldingsRequest)
            const localVarPath = `/v1/financial_connections/investments/holdings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getInvestmentHoldingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get investment transactions
         * @param {GetInvestmentTransactionsRequest} getInvestmentTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvestmentTransactions: async (getInvestmentTransactionsRequest: GetInvestmentTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getInvestmentTransactionsRequest' is not null or undefined
            assertParamExists('getInvestmentTransactions', 'getInvestmentTransactionsRequest', getInvestmentTransactionsRequest)
            const localVarPath = `/v1/financial_connections/investments/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getInvestmentTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refreshes the Asset Report in JSON format.
         * @param {RefreshAssetReportRequest} [refreshAssetReportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAssetReport: async (refreshAssetReportRequest?: RefreshAssetReportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/asset_report/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshAssetReportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Call this endpoint upon receiving a SYNC_REQUIRED webhook. This will keep the financial connections data up to date.
         * @summary Sync financial connections data
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncFinancialConnectionsData: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('syncFinancialConnectionsData', 'body', body)
            const localVarPath = `/v1/financial_connections/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sync transactions
         * @param {SyncTransactionsRequest} syncTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncFinancialConnectionsTransactions: async (syncTransactionsRequest: SyncTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncTransactionsRequest' is not null or undefined
            assertParamExists('syncFinancialConnectionsTransactions', 'syncTransactionsRequest', syncTransactionsRequest)
            const localVarPath = `/v1/financial_connections/transactions/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity
         * @param {string} entityIdToUpdate 
         * @param {UpdateEntityRequest} updateEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntity: async (entityIdToUpdate: string, updateEntityRequest: UpdateEntityRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityIdToUpdate' is not null or undefined
            assertParamExists('updateEntity', 'entityIdToUpdate', entityIdToUpdate)
            // verify required parameter 'updateEntityRequest' is not null or undefined
            assertParamExists('updateEntity', 'updateEntityRequest', updateEntityRequest)
            const localVarPath = `/v1/entities/{entity_id_to_update}`
                .replace(`{${"entity_id_to_update"}}`, encodeURIComponent(String(entityIdToUpdate)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEntityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get liabilities
         * @param {GetLiabilitiesRequest} getLiabilitiesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1FinancialConnectionsLiabilitiesPost: async (getLiabilitiesRequest: GetLiabilitiesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getLiabilitiesRequest' is not null or undefined
            assertParamExists('v1FinancialConnectionsLiabilitiesPost', 'getLiabilitiesRequest', getLiabilitiesRequest)
            const localVarPath = `/v1/financial_connections/liabilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication fuseApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Api-Key", configuration)

            // authentication fuseClientId required
            await setApiKeyToObject(localVarHeaderParameter, "Fuse-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getLiabilitiesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FuseApi - functional programming interface
 * @export
 */
export const FuseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FuseApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to generate an Asset Report for a user.
         * @param {CreateAssetReportRequest} [createAssetReportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAssetReport(createAssetReportRequest?: CreateAssetReportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAssetReportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAssetReport(createAssetReportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create entity
         * @param {CreateEntityRequest} createEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntity(createEntityRequest: CreateEntityRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEntityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntity(createEntityRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a link token to start the process of a user connecting to a specific financial institution.
         * @param {CreateLinkTokenRequest} [createLinkTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLinkToken(createLinkTokenRequest?: CreateLinkTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateLinkTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLinkToken(createLinkTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a session that returns a client_secret which is required as a parameter when initializing the Fuse SDK.
         * @param {CreateSessionRequest} [createSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSession(createSessionRequest?: CreateSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(createSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API to exchange a public token for an access token and financial connection id
         * @param {ExchangeFinancialConnectionsPublicTokenRequest} [exchangeFinancialConnectionsPublicTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exchangeFinancialConnectionsPublicToken(exchangeFinancialConnectionsPublicTokenRequest?: ExchangeFinancialConnectionsPublicTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeFinancialConnectionsPublicTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exchangeFinancialConnectionsPublicToken(exchangeFinancialConnectionsPublicTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the Asset Report in JSON format.
         * @param {GetAssetReportRequest} [getAssetReportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetReport(getAssetReportRequest?: GetAssetReportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAssetReportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetReport(getAssetReportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get entity
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntity(entityId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEntityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntity(entityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get account details
         * @param {GetFinancialConnectionsAccountDetailsRequest} getFinancialConnectionsAccountDetailsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFinancialConnectionsAccountDetails(getFinancialConnectionsAccountDetailsRequest: GetFinancialConnectionsAccountDetailsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFinancialConnectionsAccountDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFinancialConnectionsAccountDetails(getFinancialConnectionsAccountDetailsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get accounts
         * @param {GetFinancialConnectionsAccountsRequest} getFinancialConnectionsAccountsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFinancialConnectionsAccounts(getFinancialConnectionsAccountsRequest: GetFinancialConnectionsAccountsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFinancialConnectionsAccountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFinancialConnectionsAccounts(getFinancialConnectionsAccountsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get balances
         * @param {GetFinancialConnectionsBalanceRequest} getFinancialConnectionsBalanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFinancialConnectionsBalances(getFinancialConnectionsBalanceRequest: GetFinancialConnectionsBalanceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFinancialConnectionsAccountBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFinancialConnectionsBalances(getFinancialConnectionsBalanceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get account owners
         * @param {GetFinancialConnectionsOwnersRequest} getFinancialConnectionsOwnersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFinancialConnectionsOwners(getFinancialConnectionsOwnersRequest: GetFinancialConnectionsOwnersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFinancialConnectionsOwnersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFinancialConnectionsOwners(getFinancialConnectionsOwnersRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get transactions
         * @param {GetTransactionsRequest} getTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFinancialConnectionsTransactions(getTransactionsRequest: GetTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFinancialConnectionsTransactions(getTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get investment holdings
         * @param {GetInvestmentHoldingsRequest} getInvestmentHoldingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvestmentHoldings(getInvestmentHoldingsRequest: GetInvestmentHoldingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvestmentHoldingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvestmentHoldings(getInvestmentHoldingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get investment transactions
         * @param {GetInvestmentTransactionsRequest} getInvestmentTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvestmentTransactions(getInvestmentTransactionsRequest: GetInvestmentTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvestmentTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvestmentTransactions(getInvestmentTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refreshes the Asset Report in JSON format.
         * @param {RefreshAssetReportRequest} [refreshAssetReportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshAssetReport(refreshAssetReportRequest?: RefreshAssetReportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAssetReportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAssetReport(refreshAssetReportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Call this endpoint upon receiving a SYNC_REQUIRED webhook. This will keep the financial connections data up to date.
         * @summary Sync financial connections data
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncFinancialConnectionsData(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncFinancialConnectionsDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncFinancialConnectionsData(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sync transactions
         * @param {SyncTransactionsRequest} syncTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncFinancialConnectionsTransactions(syncTransactionsRequest: SyncTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncFinancialConnectionsTransactions(syncTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update entity
         * @param {string} entityIdToUpdate 
         * @param {UpdateEntityRequest} updateEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntity(entityIdToUpdate: string, updateEntityRequest: UpdateEntityRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateEntityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntity(entityIdToUpdate, updateEntityRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get liabilities
         * @param {GetLiabilitiesRequest} getLiabilitiesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1FinancialConnectionsLiabilitiesPost(getLiabilitiesRequest: GetLiabilitiesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLiabilitiesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1FinancialConnectionsLiabilitiesPost(getLiabilitiesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FuseApi - factory interface
 * @export
 */
export const FuseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FuseApiFp(configuration)
    return {
        /**
         * Use this endpoint to generate an Asset Report for a user.
         * @param {CreateAssetReportRequest} [createAssetReportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetReport(createAssetReportRequest?: CreateAssetReportRequest, options?: any): AxiosPromise<CreateAssetReportResponse> {
            return localVarFp.createAssetReport(createAssetReportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create entity
         * @param {CreateEntityRequest} createEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntity(createEntityRequest: CreateEntityRequest, options?: any): AxiosPromise<CreateEntityResponse> {
            return localVarFp.createEntity(createEntityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a link token to start the process of a user connecting to a specific financial institution.
         * @param {CreateLinkTokenRequest} [createLinkTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLinkToken(createLinkTokenRequest?: CreateLinkTokenRequest, options?: any): AxiosPromise<CreateLinkTokenResponse> {
            return localVarFp.createLinkToken(createLinkTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a session that returns a client_secret which is required as a parameter when initializing the Fuse SDK.
         * @param {CreateSessionRequest} [createSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(createSessionRequest?: CreateSessionRequest, options?: any): AxiosPromise<CreateSessionResponse> {
            return localVarFp.createSession(createSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API to exchange a public token for an access token and financial connection id
         * @param {ExchangeFinancialConnectionsPublicTokenRequest} [exchangeFinancialConnectionsPublicTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangeFinancialConnectionsPublicToken(exchangeFinancialConnectionsPublicTokenRequest?: ExchangeFinancialConnectionsPublicTokenRequest, options?: any): AxiosPromise<ExchangeFinancialConnectionsPublicTokenResponse> {
            return localVarFp.exchangeFinancialConnectionsPublicToken(exchangeFinancialConnectionsPublicTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Asset Report in JSON format.
         * @param {GetAssetReportRequest} [getAssetReportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetReport(getAssetReportRequest?: GetAssetReportRequest, options?: any): AxiosPromise<GetAssetReportResponse> {
            return localVarFp.getAssetReport(getAssetReportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity(entityId: string, options?: any): AxiosPromise<GetEntityResponse> {
            return localVarFp.getEntity(entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account details
         * @param {GetFinancialConnectionsAccountDetailsRequest} getFinancialConnectionsAccountDetailsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinancialConnectionsAccountDetails(getFinancialConnectionsAccountDetailsRequest: GetFinancialConnectionsAccountDetailsRequest, options?: any): AxiosPromise<GetFinancialConnectionsAccountDetailsResponse> {
            return localVarFp.getFinancialConnectionsAccountDetails(getFinancialConnectionsAccountDetailsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get accounts
         * @param {GetFinancialConnectionsAccountsRequest} getFinancialConnectionsAccountsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinancialConnectionsAccounts(getFinancialConnectionsAccountsRequest: GetFinancialConnectionsAccountsRequest, options?: any): AxiosPromise<GetFinancialConnectionsAccountsResponse> {
            return localVarFp.getFinancialConnectionsAccounts(getFinancialConnectionsAccountsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get balances
         * @param {GetFinancialConnectionsBalanceRequest} getFinancialConnectionsBalanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinancialConnectionsBalances(getFinancialConnectionsBalanceRequest: GetFinancialConnectionsBalanceRequest, options?: any): AxiosPromise<GetFinancialConnectionsAccountBalanceResponse> {
            return localVarFp.getFinancialConnectionsBalances(getFinancialConnectionsBalanceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account owners
         * @param {GetFinancialConnectionsOwnersRequest} getFinancialConnectionsOwnersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinancialConnectionsOwners(getFinancialConnectionsOwnersRequest: GetFinancialConnectionsOwnersRequest, options?: any): AxiosPromise<GetFinancialConnectionsOwnersResponse> {
            return localVarFp.getFinancialConnectionsOwners(getFinancialConnectionsOwnersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transactions
         * @param {GetTransactionsRequest} getTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinancialConnectionsTransactions(getTransactionsRequest: GetTransactionsRequest, options?: any): AxiosPromise<GetTransactionsResponse> {
            return localVarFp.getFinancialConnectionsTransactions(getTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get investment holdings
         * @param {GetInvestmentHoldingsRequest} getInvestmentHoldingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvestmentHoldings(getInvestmentHoldingsRequest: GetInvestmentHoldingsRequest, options?: any): AxiosPromise<GetInvestmentHoldingsResponse> {
            return localVarFp.getInvestmentHoldings(getInvestmentHoldingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get investment transactions
         * @param {GetInvestmentTransactionsRequest} getInvestmentTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvestmentTransactions(getInvestmentTransactionsRequest: GetInvestmentTransactionsRequest, options?: any): AxiosPromise<GetInvestmentTransactionsResponse> {
            return localVarFp.getInvestmentTransactions(getInvestmentTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Refreshes the Asset Report in JSON format.
         * @param {RefreshAssetReportRequest} [refreshAssetReportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAssetReport(refreshAssetReportRequest?: RefreshAssetReportRequest, options?: any): AxiosPromise<CreateAssetReportResponse> {
            return localVarFp.refreshAssetReport(refreshAssetReportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Call this endpoint upon receiving a SYNC_REQUIRED webhook. This will keep the financial connections data up to date.
         * @summary Sync financial connections data
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncFinancialConnectionsData(body: object, options?: any): AxiosPromise<SyncFinancialConnectionsDataResponse> {
            return localVarFp.syncFinancialConnectionsData(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sync transactions
         * @param {SyncTransactionsRequest} syncTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncFinancialConnectionsTransactions(syncTransactionsRequest: SyncTransactionsRequest, options?: any): AxiosPromise<SyncTransactionsResponse> {
            return localVarFp.syncFinancialConnectionsTransactions(syncTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity
         * @param {string} entityIdToUpdate 
         * @param {UpdateEntityRequest} updateEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntity(entityIdToUpdate: string, updateEntityRequest: UpdateEntityRequest, options?: any): AxiosPromise<UpdateEntityResponse> {
            return localVarFp.updateEntity(entityIdToUpdate, updateEntityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get liabilities
         * @param {GetLiabilitiesRequest} getLiabilitiesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1FinancialConnectionsLiabilitiesPost(getLiabilitiesRequest: GetLiabilitiesRequest, options?: any): AxiosPromise<GetLiabilitiesResponse> {
            return localVarFp.v1FinancialConnectionsLiabilitiesPost(getLiabilitiesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FuseApi - object-oriented interface
 * @export
 * @class FuseApi
 * @extends {BaseAPI}
 */
export class FuseApi extends BaseAPI {
    /**
     * Use this endpoint to generate an Asset Report for a user.
     * @param {CreateAssetReportRequest} [createAssetReportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public createAssetReport(createAssetReportRequest?: CreateAssetReportRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).createAssetReport(createAssetReportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create entity
     * @param {CreateEntityRequest} createEntityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public createEntity(createEntityRequest: CreateEntityRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).createEntity(createEntityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a link token to start the process of a user connecting to a specific financial institution.
     * @param {CreateLinkTokenRequest} [createLinkTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public createLinkToken(createLinkTokenRequest?: CreateLinkTokenRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).createLinkToken(createLinkTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a session that returns a client_secret which is required as a parameter when initializing the Fuse SDK.
     * @param {CreateSessionRequest} [createSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public createSession(createSessionRequest?: CreateSessionRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).createSession(createSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API to exchange a public token for an access token and financial connection id
     * @param {ExchangeFinancialConnectionsPublicTokenRequest} [exchangeFinancialConnectionsPublicTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public exchangeFinancialConnectionsPublicToken(exchangeFinancialConnectionsPublicTokenRequest?: ExchangeFinancialConnectionsPublicTokenRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).exchangeFinancialConnectionsPublicToken(exchangeFinancialConnectionsPublicTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the Asset Report in JSON format.
     * @param {GetAssetReportRequest} [getAssetReportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public getAssetReport(getAssetReportRequest?: GetAssetReportRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).getAssetReport(getAssetReportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity
     * @param {string} entityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public getEntity(entityId: string, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).getEntity(entityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account details
     * @param {GetFinancialConnectionsAccountDetailsRequest} getFinancialConnectionsAccountDetailsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public getFinancialConnectionsAccountDetails(getFinancialConnectionsAccountDetailsRequest: GetFinancialConnectionsAccountDetailsRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).getFinancialConnectionsAccountDetails(getFinancialConnectionsAccountDetailsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get accounts
     * @param {GetFinancialConnectionsAccountsRequest} getFinancialConnectionsAccountsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public getFinancialConnectionsAccounts(getFinancialConnectionsAccountsRequest: GetFinancialConnectionsAccountsRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).getFinancialConnectionsAccounts(getFinancialConnectionsAccountsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get balances
     * @param {GetFinancialConnectionsBalanceRequest} getFinancialConnectionsBalanceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public getFinancialConnectionsBalances(getFinancialConnectionsBalanceRequest: GetFinancialConnectionsBalanceRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).getFinancialConnectionsBalances(getFinancialConnectionsBalanceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account owners
     * @param {GetFinancialConnectionsOwnersRequest} getFinancialConnectionsOwnersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public getFinancialConnectionsOwners(getFinancialConnectionsOwnersRequest: GetFinancialConnectionsOwnersRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).getFinancialConnectionsOwners(getFinancialConnectionsOwnersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transactions
     * @param {GetTransactionsRequest} getTransactionsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public getFinancialConnectionsTransactions(getTransactionsRequest: GetTransactionsRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).getFinancialConnectionsTransactions(getTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get investment holdings
     * @param {GetInvestmentHoldingsRequest} getInvestmentHoldingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public getInvestmentHoldings(getInvestmentHoldingsRequest: GetInvestmentHoldingsRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).getInvestmentHoldings(getInvestmentHoldingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get investment transactions
     * @param {GetInvestmentTransactionsRequest} getInvestmentTransactionsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public getInvestmentTransactions(getInvestmentTransactionsRequest: GetInvestmentTransactionsRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).getInvestmentTransactions(getInvestmentTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refreshes the Asset Report in JSON format.
     * @param {RefreshAssetReportRequest} [refreshAssetReportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public refreshAssetReport(refreshAssetReportRequest?: RefreshAssetReportRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).refreshAssetReport(refreshAssetReportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Call this endpoint upon receiving a SYNC_REQUIRED webhook. This will keep the financial connections data up to date.
     * @summary Sync financial connections data
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public syncFinancialConnectionsData(body: object, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).syncFinancialConnectionsData(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sync transactions
     * @param {SyncTransactionsRequest} syncTransactionsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public syncFinancialConnectionsTransactions(syncTransactionsRequest: SyncTransactionsRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).syncFinancialConnectionsTransactions(syncTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity
     * @param {string} entityIdToUpdate 
     * @param {UpdateEntityRequest} updateEntityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public updateEntity(entityIdToUpdate: string, updateEntityRequest: UpdateEntityRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).updateEntity(entityIdToUpdate, updateEntityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get liabilities
     * @param {GetLiabilitiesRequest} getLiabilitiesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuseApi
     */
    public v1FinancialConnectionsLiabilitiesPost(getLiabilitiesRequest: GetLiabilitiesRequest, options?: AxiosRequestConfig) {
        return FuseApiFp(this.configuration).v1FinancialConnectionsLiabilitiesPost(getLiabilitiesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


